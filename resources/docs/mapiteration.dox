/** 

    @page mapiteration Iterating over an STL map

    @author troy d. straszheim <a href="http://www.resophonic.com">@<troy@resophonic.com@></a>

    @section Synopsis

    We'll iterate over an STL @c map which maps a subatomic particle
    by name to a class containing some of its characteristics.  An STL
    @c string is the key, and some class @c Particle is the value.
    We'll create this map and then loop over with a regular loop and
    with the STL algorithms @c for_each and a @c copy.

    @section Declarations 

    Here's the top of the file for all our examples, showing the
    necessary @c #include statements and the @c Particle class.

    @dontinclude mapforloop.cxx.example
    @until };

    @section create Create and populate

    And here is how we would build a simple map.  When we create a map
    it is empty, of course.  Map's @c operator[] must return a
    reference to an object (which represents the "value" of the
    key/value pairs in the map), so the map creates one with the value
    type's default constructor, and then returns a reference to it.
    Therefore this is not a good way to check to see if a value is
    contained in the map, since there will always be an object on the
    other end of that call to @c operator[].  To see if there is an
    object in there, you want @c find(), which will return an
    iterator: and an iterator (by being equal to @c end()) can point
    to "nothing", so to speak, and thereby indicate that the key was
    not found.

    Anyhow it is easy to declare and populate this map:

    @until Neutron

    Notice statements of the form:

    @code 
    m["Neutron"].mass = 0.1056;
    @endcode

    and think about what is happening there.  The map looks for a key
    that matches "Neutron".  If it found one, it would return a
    reference to the key object (of type @c Particle in this case)
    that corresponds to that value.  Since it doesnt find one, it
    creates a key/value pair, puts it into the map, and returns a
    reference to the value part of it.  So the expression 
    <tt> m["Neutron"] </tt> is of type @c Particle.  This of course, is why
    the compiler allows you to use the dot operator to access the
    data member @c mass.
    
    Physicists:  can you find the error above?

    @section loopit A written-out loop

    Now let's see how we could walk this map with a written-out
    loop.  In the long run you won't want to do things this way, for
    reasons of style and efficiency that we shall see later when the
    other techniques are explained, but this shows you what is going
    on under the hood.

    @until }

    So an iterator over a @c map<string,Particle> is basically a
    pointer to a @c pair<string,Particle>.  @c pairs have two
    members, @c first and @c second, which in this case correspond to
    "key" and "value", or some instance of @c string and the
    associated @c Particle.

    The problem with this is that it doesn't really appeal to your
    sense of sloth.  You shouldn't have to write all that <tt> cout <<
    </tt> stuff just to print a @c Particle, or for that matter a @c
    pair, and that @c for loop business is a little wordy.  If you
    want to dump the map you can write this loop, but then when you
    want to dump it again, elsewhere, you will copy and paste this
    code, and then when you change your map or change the contents of
    @c Particle, you have to go back and find all of these code
    pastings and recode them.  Worse, they'll could cause a crash.
    Worse yet, they could cause a crash, but only sometimes.  Much
    worse they could not cause a crash at all, but corrupt things to
    the point where a crash occurs elsewhere.  You should be feeling a
    bit of a chill at this point.  Well this corruption probably
    wouldn't occur with just print-type statements, but if you have
    eighteen copies of a for loop that rescale things or do pointer
    manipulations in your code you're looking at a lot of boring
    hunting and recoding.  If on the other hand, you're looking at
    somebody else's code and hunting all the for-loops, you're looking
    at 25-to-life for homicide, unless you're in Texas, in which case
    we could be talking about The Chair...

    Here's the code to that example:
    <a class="el" href="mapforloop.cxx"> mapforloop.cxx</a>

    @section for_each Using for_each()

    Enough with the soapbox.  Let's do it with the STL algorithm @c
    for_each().

    With something like @c vector<int>, calling @c for_each is simple
    and beautiful:
    @code
    vector<int> v;  // assume v contains a bunch of stuff

    void printInt(const int& i) {
      cout << i;
    }      		   

    for_each(v.begin(), v.end(), printInt);
    @endcode
    
    See @ref functors for some more examples of calling for_each on
    vectors of stuff.  @c printInt is a simple function, but you can
    pass these STL algorithms arbitrarily complicated (and "powerful", which I
    realize is often synonymous with "confusing and poorly
    documented") function objects.

    But what we're interested in here is how the data appears to the
    container.  In the case of a simple container like a @c set or a
    @c vector, it is just the contained object.  Maps, on the other
    hand, contain pairs of objects, and the algorithm passes the whole
    pair to the function it is called with.

    Therefore in the case of our @c map<string, Particle> the
    following will not compile:
    @code
    map<string, Particle> m;  // assume it is populated

    void printParticle(const Particle& p) {
      cout << "Particle has mass " << p.mass << endl;
    }

    for_each(m.begin(), m.end(), printParticle);
    @endcode

    and that is because what is passed to @c printParticle is not a
    @c Particle, but a @c pair<string,Particle>.  So it should look
    like this:

    @dontinclude for_each1.cxx
    @skip printPair
    @until for_each
    @until }
    
    which produces this output:

    @code 
    Particle:Electron mass:0.000511
    Particle:Muon mass:0.1056
    Particle:Neutron mass:0.94
    Particle:Proton mass:0.938
    Particle:Tau mass:1.777
    @endcode

    @c printPair takes as an argument a const reference to a @c pair.
    If it took them by value, a copy construction would be required,
    and if these objects were large, that could be costly.   Anytime
    you write a function that looks at an object but should not be
    allowed to modify it, you should pass it by const reference.

    @todo 
    @li can copy to @c ostream_iterator<cout> if your class has a @c operator<<()
    @li Warnings about modifying keys: invalidates iterators.


*/
