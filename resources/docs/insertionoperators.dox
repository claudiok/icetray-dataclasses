/** 

    @page insertionoperators Insertion operators: operator<<()

    @author troy d. straszheim <a href="http://www.resophonic.com">@<troy@resophonic.com@></a>

    @section Synopsis

    So, when I write
    @code
    {
      int i=4;
      cout << "i is " << i << endl;
    }
    @endcode

    and I see @code i is 4 @endcode what's happening there?  And why
    is that better than just @code printf("i is %d", i); @endcode, anyway?

    Well, I think the @c printf syntax has its advantages, and in
    fact there is a library called @c boost::format which allows you
    to do this in C++.  "Hang on", you say, "but you @em can use @c
    printf in C++!".

    Well, you're right, but @c printf can't handle user-defined types.
    It is also easy to crash: as we all know, if you mismatch your
    arguments and your format string, that is you specify @c %s and
    you accidentally put an @c int in its' position, like this: @code
    int i; char *s; //assume this points to something reasonable
    printf("i is %s, and s is %s", i, s); @endcode

    (notice that @c i is paired with @c @%s), you're going to get a
    bunch of garbage on the screen at least, and probably a core dump.

    As for those user-defined types.  @c printf can't do this:
    
    @code
    class Particle {
    public:
      string name;
      float mass;
    };

    Particle m;

    printf("mystruct is %???", m);
    @endcode

    Obviously @c @%??? isn't a valid @c printf format string.  The point
    is that none exists for @c Particle, and straight C does not
    provide a way for you to supply one.

    But C++ does.  Well, it doesn't for @c printf, but you do have a
    way to send your own classes to @c cout or some other output
    stream, for instance a file, stringstream or socket.  Or the boot
    sector of your hard drive, if you're persistent enough, or maybe
    your audio device, if you like to be startled.

    So with the @c Particle class above, how can I make it possible
    to do something like 
    @code
    Particle my_particle;
    cout << "the particle is: " << my_particle << endl;
    @endcode.
    
    The trick is the @c <<.  That's @c operator<<(), called the @e
    insertion operator, because it "inserts" the object into the
    output stream, which in this case is @c cout.  The statement above
    will call a function with the following prototype:

    @code
    ostream& operator<<(ostream&, const Particle&);
    @endcode

    Well, it could call one that passes its argument by value, or one
    that takes a non-const reference to Particle, and it could also
    call one that returns @c void or something else, but then the full
    statement wouldn't compile.  More details on that later.  The form
    you want is the one above.

    Here's a full implementation:

    @code
    ostream& operator<<(ostream& o, const Particle& p) 
    {    
    	 o << "[Particle name:" << p.name 
           << " mass:" << p.mass << "]";
         return o;
    }
    @endcode
    
    So in that first code snippet, the compiler calls this function
    with @c o set to @c cout, and @c p a const reference to @c
    myparticle.

    Here's a test program:
    @include insertionoperator.cxx

    and the output:
    @code
    The electron says: [Particle name=Electron	mass=0.000511]
     and the tau says: [Particle name=Tau	mass=1.777]
    @endcode
        
    Now, this comes in really handy when you're debugging.  If all
    your classes have these insertion operators defined, you can just
    "cout" them where you are having problems.
    
    The brackets might look funny.  They are there to make it easier
    to tell what is what.  They're really important, actually, when
    classes contain one another.  Say I have an @c Event that contains a
    @c Particle:

    @dontinclude insertionoperator2.cxx
    @skip Event
    @until };

    and I define an insertion operator for the @c Event that looks
    like this:

    @until }

    Then when I am somewhere and I want to see what my @c Event looks
    like, I can tell where my contained @c Particle begins and ends
    without problems.  Here's another example program:

    @include insertionoperator2.cxx	

    and the output:
    @code
My event looks like this: 
[Event x=3.14159 y=3.14159 z=3.14159
	[Particle name=Elephantino! mass=999999]
]
    @endcode

    So I did @e not have to rewrite a print routine for the @c Event
    and all of its subobjects, and I can clearly see where the 
    @c Event begins and ends, and where the contained @c Particle begins
    and ends.

    This insertion operator arguably should be a convenience function
    that you should always provide your clients.  If you wrote a
    RationalNumber class and didn't provide an operator*(), you'd be
    rather negligent.
    
    This technique is also quite handy when it comes to printing
    containers.  You could roll your own @c operator<<() for a @c
    vector of @c Event s, for instance.  When writing and debugging
    functors (see @ref functors) and otherwise traversing data
    structures that work with STL algorithms (see @ref mapiteration)
    being able to easily dump what's going on to @c cout or a file can
    really come in handy.

*/
