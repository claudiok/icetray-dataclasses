/**

@page memorymanagement Memory Management

@author troy d. straszheim <a href="http://www.resophonic.com">@<troy@resophonic.com@></a>

@section Responsibilities

With respect to memory management, the responsibilities of a module
are to not leak any memory and to not cause heap corruption via
double-delete or deleting something it was not supposed to.  In a
module, every @c new must be matched with a corresponding @c delete,
every @c malloc() matched with a corresponding @c free().  Think of @c
malloc and @c new as a request to the operating system to use some
memory for a while: @c free() and @c delete tell the operating system
that you are done with it.  Whether the operating system actually
reacts to these function calls (aside from remembering that the region
of memory is available for allocation again) is, in theory, immaterial
from the standpoint of the calling process.

Memory that is (de)allocated with these functions is called
"dynamically allocated" memory, in contrast to memory that is either
static (like globals, which never go away) or memory that is said to
be "on the stack", like variables that are local to a function, which
are created and destroyed without the programmer's intervention.

@section rfmadd Reading deleted memory and double-deletes

In order to be able to call @c delete when appropriate on some
allocated block, a given piece of code must know that no other code
will attempt to access or @c delete that memory later.  Memory is not
necessarily overwritten as soon as it is deleted, therefore code that
reads via a pointer to some memory that has already been deleted often
gets more-or-less reasonable values and does not manifest bugs until
later in the program's execution.  A block that is deleted twice,
called a @em double-deletes, results in what is called @em undefined
@em behavior, which some would argue is political doubletalk for
"causes heap corruption, resulting in crashes much later, in
completely unrelated sections of code".  A program with a corrupted
heap can even crash in different places over several runs on exactly
the same input data, because the actual pattern of phyical memory
allocated to the program can vary under the influence of the memory
use of other processes.

@section Leaks

"Leaked" memory, on the other hand, will not cause crashes or
corruption.  Leaked memory is simply dynamically allocated memory
(again @c newed or @c malloc()ed memory), the pointers to whom have
been lost, for instance because these pointers have gone out of scope
or been overwritten by other values.  The operating system will
reclaim all memory requested by the program when the program exits,
whether that program exits normally or by way of core dump.  In a
short-running program therefore leaks can be of relatively little
concern: I forgot to @c delete something, but the operating system did
it for me just about when I would have done it anyway, no worries.

In a long running program however, especially one like Icetray, leaks
can be a showstopper.  One sets the framework and a number of modules
in motion, runs @c top, and watches the memory in use swell without
bound.  A module appears to be forgetting to delete something on every
event, but which?  And which part of the module?  Well, @c top won't
tell you, for sure.  These bugs can also be extremely hard to track
down.  In desperation the programmer finds some good places to put
some more @c deletes, runs, and the leak goes away.  cvs commit, bug
fixed.  It then turns out that these @c deletes happen twice in some
situations, and a core dump appears at random intervals somewhere on
the other end of the application.

@section Icetray

In the Icetray paradigm, Icetray modules are created and given access
to a frame, which would contain for instance an @c I3Event.  The
module examines the event, adds something to it, and returns control
to the frame.  It is the framework's responsibility to delete
everything in the frame when processing is finished.  The @c I3Event
in turn must @c delete everything it contains when it is itself
deleted.  Failure to do so is a memory leak.  The framework and event,
of course, may not double-delete anything.

The "may not double-delete" requirement brings something into sharp
focus: If two objects contain pointers to the same object in the
event, how is one to know that the other will take responsibility for
@c delete -ing said object?  If I am given a pointer to an object in a
function call, is it my responsibility to delete it?  How about if I
am given a pointer to an object as a return value?  In some cases it
is possible to develop policies to manage this complexity, but of
course it is desirable, when possible, to reduce complexity by adding
a layer of abstraction.  Programmers are lazy, and a design principle
is that classes will be misused.  Good classes are difficult to
misuse, and one truly appreciates them, as they reduce the size of the
bug-search-space.

Continue to @ref sharedpointer

*/
