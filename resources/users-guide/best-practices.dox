/**
@page best-practices Best practices:  how to use the dataclasses in your code, and do it well.

@author Troy Straszheim

@section remarks General remarks

Programming is not a contest to see if you know all the most compact
legal expressions and obscure features of C++.  Programming is a test
to see if you are able to write code that runs correctly and expresses
the overal logic and structure of your program with "breathtaking
clarity" [Ristad].  You will find in the long run that that these two
considerations (running correctly and being clear) are actually the
same.  There exists no guarantee that any given piece of code is
correct, only a degree of belief in the correctness of the code; this
degree of belief is a function of the clarity of the code and/or test
suites associated with the code.

Einstein's requirement ("So einfach wie möglich und so kompliziert wie
nötig", or "As simple as possible and as complicated as necessary")
applies just as precisely to software as it does to theory.  There
@em does exist software that is elegant, crisp and beautiful in structure.
If the tasks your software must complete are complex, the only way to
create software that will be maintainable and verifiably correct will
be to strive for this goal in your implementation.

The central goal of module implementation is correctness.  Performance
is secondary to correctness.  "Correctness" means that all specified
functions are implemented strictly according to the module
specification, without memory leaks, segmentation faults, core dumps,
bus errors or other such nastiness.  

@section scope Use the narrowest possible scope.

Declare variables in the narrowest possible scope.  If you only use a
variable in a procedure, do not declare it global, make it local to
the procedure.  Similarly, if you only use a variable in one of the
branches of a conditional statement, make it local to that branch.
This makes the code easier to understand, and reduces the risk of
improperly initialized variables and name conflicts. 

@section pointers    If you must use pointers

Use as few pointers as possible in your data structures.  Resist the
tendency to introduce new pointers into data structures in an attempt
to reduce typing or make the code faster.  The overhead of maintaining
an ever-growing tangle of pointers from everything to everything else
(and back) will quickly eliminate any performance gains you might
achieve, bloat your code (don't forget, minimum four bytes per
pointers) and you will use up that time you spent typing, since you
will be busy hunting bugs and explaining your code to others who are
unable to read it.

To save typing, create convenience functions that capture the
relationships or do the lookups you need, instead of introducing extra
pointers or index variables.

@section incrementdecrement Avoid postfix increment/decrement

Do
@code
Rational r;
++r;
@endcode
not
@code
Rational r;
r++;
@endcode
When @c r is a user-defined type, this will avoid the creation of a temporary in some cases.


Furthermore, do not mutate variables inside complex expressions or the
argument to a function call.  For instance, replace <tt> f(x++); </tt>
with <tt> f(x); ++x; </tt>

@section assert	     Using assert() 

Your software should make agressive use of the @c assert() statement.
If something goes awry, the program should not be able to progress
more than a statement or two before an assertion discovers the error
and halts execution.  Functions should check their arguments upon
entry to the function, and should check their return values before
they return them.  They should also check values that they will pass
to other functions before it calls those functions, and check the
return values of those functions.

Ristad and Yianilos admonish that rougly 50% of your code should be
asserts, as high as 75% when performing pointer arithmetic!  No
kidding.  This can actually make code very easy to read: at every
point in the code, it is clear what the preconditions for the next
statement are.  Take, for instance, a sample from their <i>Library of
Practical Abstractions</i>, a truly elegant and clear piece of work:

@code
unsigned 
hash_table_index (const hash_table_t *table, const void *key_p)
{
  unsigned slot_index, entry_index;

  assert(table); 
  assert(key_p);
  slot_index = hash_table_probe(table, key_p);
  assert(slot_index < table->slot_count);
  entry_index = table->slots[slot_index];
  assert((entry_index < table->entry_count) ||
	 (entry_index == hash_table_null_index(table)));
  return(entry_index);
}
@endcode

With the extensive checking involved, we can be reasonably sure that
this hash table is in a valid state and that we have returned the
correct answer.  See @ref testsuites for more extensive discussion and
information on how to write your own test suites.


Replace compund asserts with simple asserts.  This makes debugging easier.  For example, replace
@code
assert(music.is_funky() && (x >= 14));
@endcode
with
@code
assert (music.is_funky());
assert (x >= 14); 
@endcode

The code must also run correctly if @c NDEBUG is defined and all the
@c assert() macros vanish.  This means of course that no side effects
must occur in your calls to @c assert()


@section optimization Compiler optimizations

Compiler optimizations are a source of compiler errors, and code
compiled with optimizations can lead debuggers to lie to you.  You
don't want this.  Never use code compiled with optimizations (@c -O2,
for instance), @c assert() turned off (which is @c -DNDEBUG), or
without symbol tables (that is, without @c -g), for debugging.  See
the @c gcc manual page for more information on the exact meaning of
these and related flags.

When you are quite sure of the correctness of your implementation,
your debugging is finished, you have begun "production" runs and need
additional performance, then you may turn on these various
optimization flags.

So the important parts of your compile lines during development should
look something like this:

@code
gcc -g -c MyFile.cxx -I/various/include/directories ...
@endcode
and the "production" version may look like this
@code
gcc -O2 -DNDEBUG -c MyFile.c -I/various/include/directories ...
@endcode

@section cutnpaste Cutting and pasting

Your implementation should contian as little duplicated code as
possible.  If you find yourself cutting and pasting, your design is
probably poor.  Try to factor out the commonalities in your code into
one function, module or object.  [TODO: example]

@section References

Significant debt to:
@verbatim
Eric Sven Ristad and Peter N. Yianilos 
Library of Practical Abstractions
http://www.mnemonic.com/software/libpa
February 1998
@endverbatim

@section Unfinished
@subsection references  Use references instead of pointers
@li Hard to make references to NULL
@li Dont have to @c delete anything held by a reference, less chance for memory leaks
@li Easier syntax

@subsection macros Avoid macros.  Use inline functions

Macros are a big source of bugs.  Use inline functions (or just
regular functions) instead.  

@subsection const Use const wherever possible

@subsection conventions Coding conventions and formatting
@li emacs C++ indentation style

@subsection selectors Writing and using selectors

*/
