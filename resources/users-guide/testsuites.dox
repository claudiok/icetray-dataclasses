/**
@page testsuites Test suites:  how to write and run them

@author troy d. straszheim <troy@resophonic.com>

@section general Test suites in general

The best way to verify the correctness of an implementation is to
fully exercise all functionality with an independent implementation.
"Thorough" means: a run of the test suite to completion without error
should be enough to convince an aggressive skeptic that the
implementation is correct.  The independent implementation itself
should be so simple that it is plausibly correct.  (This specification
from the Library of Practical Abstractions manual, see References at
the bottom of this document.)

One should provide test suites for all code.  We have included a
testing mechanism in the dataclasses that will easily allow you to
build and run your own test suites and the test suites of others.

A test suite should run to completion in a reasonable amount of
time. An unsuccessful test should dump core by calling ensure() or
fail().

Test suites should exercise the interface of a class in all normal
and all borderline cases.  They should demonstrate everything that
it is possible to do with a class and demonstrate that a class
behaves reasonably when misused.

@subsection asdocs Test suites as documentation and insurance

Test suites serve several additonal purposes.  They allow people other
than the original authors to fix bugs in modules with confidence that
they have not introduced additional bugs.  They serve as excellent
documentation for how to use modules as well:  if a testsuite is
thorough it gives the interface of a module a thorough workout, and
therefore should demonstrate all possible uses and borderline use
cases, which can be an excellent reference if you are trying to
figure out how to use the class yourself.

Time invested in writing test suites is time well invested.

@section indataclasses  Test suites in the dataclasses

This document shows first how to add your own test module to the
dataclasses and how to run them, and then how to add testsuites to
your own project.

The source for the dataclasses unit tests are located in @c
dataclasses/private/test.  As of this writing, the test suites are not
yet finished.  
@todo Add more tests, better ones.

We will look at @c I3HitTest.cxx, a test suite
for the fairly trivial class @c I3Hit.  As a consequence, the tests
themselves are also quite trivial and therefore not a good example of
the desired rigor, but this example makes it easy to see what one must
do in order to create one's own test suites.

@todo add examples of tests with the desired rigor.

Here is the definition of @c I3HIt:

@dontinclude I3Hit.h.example
@skip class I3Hit
@until ClassDef
@until };

Now we will walk through <tt> dataclasses/private/test/I3HitTest.cxx
</tt> and see how a test suite is constructed.  The discussion is
intended to make it easy to follow along and create your own along the
way, and the file itself @c I3HitTest.cxx is very heavily commented so
that you can later copy it to your project and easily accomplish the
customization.  Let's take @c MyClass to denote the class for which
you are constructing a test suite.

@dontinclude I3HitTest.cxx.example
@until using

First we include the various header files, including that of our
class.  Change <tt> dataclasses/I3Hit.h </tt> to 
<tt> dataclasses/I3MyClass.h.</tt>  (When you later add testsuites to
your own project, this will of course be @c yproject/MyModule.h)

@until };

Whatever this @c struct @c I3HitTest contains will be visible inside
each of the test routines, below.  Change this to @c I3MyClassTest and
put in whatever you will need in all of your routines.  Consult the
TUT man pages for more details.  Most will not want to have anything
in this structure, as it is just as easy to put them inside the
routines, below.  Read on for more.

@until object

Change the @c I3HitTest here to @c I3MyClassTest.  This is part of the
mechanism that registers the individual test routines with the testing
framework.  Don't mess with the @c factory::object bit.

@skip namespace
@until }

Change @c "I3Hit" to @c "I3MyClass".  This is actually the identifier
that you will use to tell the testing framework to run your unit
tests, if you wish to specify them.  Avoid using spaces or things that
would confuse the shell: you will have to escape them with backslashes,
singlequotes, or what-have-you.

@bug Compiler bug: gcc 3.3 on MacOSX has a severe bug.  To run on this
platform you must also change @c tut::factory @c t to some name that
is unique among all the testsuites, like 
@code 
tut::factory myparticulartest("myparticulartest");
@endcode
Otherwise your linker will complain of multiply defined symbols in
anonymous namespaces.

@skip namespace
@until }

Here we have our first actual test routine.  Modify these to contain
thorough and rigorous of your module.  To create new routines, copy
this <tt> object::test<2>() </tt> routine and change the @c 2 to a
different positive integer between 1 and 50.

The <tt> template<> template<> </tt> business is necessary, as the
testing framework uses template specialization as a function
registration mechanism.  At test running time, the routines will be
run in ascending order by their integer (1-50) argument, or you will
be able to specify individual routines by number.

@section assertion Assert type statements
@skip template
@until ensure
@until ensure

In "TUT", @c assert() is called @c ensure().  @c ensure() can have a
string message associated with the assertion.

@until ensure_equals
@until ensure_equals

@c ensure_equals is similar.  Why one would have this in addition to
just @c ensure, I don't really know off hand.  Seems that 
<tt> ensure(a==b) </tt> would work just as well as @c ensure_equals(a,b).

@until tolerance
@until tolerance

@c ensure_distance() is used to test that things are within some
distance of one another.  With floating point operations this is often
necessary.  TODO: explain why in more detail.  

@until fail

A call to @c fail fails unconditionally with a message.

@section running Running the test suites

Building the dataclasses also builds a test driver program called @c
dataclasses-test in the @c Linux-i386/bin directory of your workspace.
(change Linux-i386 to fit your architecture).
This program contains all the @c object::test<n>() routines from all
of the test moduless in the @c private/test directory.

Running this program without arguments displays some friendly help:

@verbatim
host% Linux-i386/bin/dataclasses-test
dataclasses test application.
Usage: Linux-i386/bin/dataclasses-test list|all|testgroup [testnumber]
       list: List all groups
       all: Run all tests
       testgroup [testnumber]: Run entire test group,
       or just testnumber within that group
@endverbatim

Listing the test groups looks like this:

@verbatim
30% Linux-i386/bin/dataclasses-test list
registered test groups:
  I3Hit
  I3MCHit
  I3Track
  InIceExtractorExample
@endverbatim

You can run one particular test group by specifying it on the command line:

@verbatim
31% Linux-i386/bin/dataclasses-test I3Hit

I3Hit: ......

tests summary: ok:6
@endverbatim

You can run all tests with <tt> dataclasses-test all </tt>, or specify one particular routine (if, say, you are chasing some bug), by specifying its number:

@verbatim
34% Linux-i386/bin/dataclasses-test I3Hit 4

I3Hit: .

tests summary: ok:1
@endverbatim

@section yourown Building testsuites for your own project

You will want to build your own testsuites for your own projects.
You can see the files in @c dataclasses for an example.  You can
follow along here if you are anxious to start now or skip ahead and
read "Test suites in the dataclasses" to see what is coming.  You may
want to create a testsuite in the dataclasses itself before you add
the datacalssd

Your @c localDefns.mk should contain
@verbatim
USES_TOOLS += roost TUT
DUMMY_TOOLS += roost TUT
@endverbatim

The important bit is the @c TUT.  If your project uses the @c
dataclasses then it also uses @c roost, and so that should be there
as well.

Your @c project.mk should contain
@verbatim
CXX_BIN_NAMES := myproject-test
@endverbatim
where @em myproject is of course just the name of your project.  

You will create a directory to hold the testsuites, @c
myproject/private/test,  and in it you will put the driver program, 
@c myproject-test.cxx, which should contain simply:
@code
#include "TUT/runtests.cxx"
@endcode

If you wish for some reason to customize the driver program, you can
copy @c runtests.cxx from the TUT tool and customize it.  This isn't
recommended, as soon we will need to run the test across all projects
on a regular basis, and we need a consistent interface.

Then copy the @c I3HitTest.cxx from the @c dataclasses/private/test
directory into your @c private/test directory and customize as above.

Then run @c ant and off you go.

@section References

The "tut" testing framework, http://tut-framework.sourceforge.net.

@verbatim
Eric Sven Ristad and Peter N. Yianilos 
Library of Practical Abstractions
http://www.mnemonic.com/software/libpa
February 1998
@endverbatim

*/
