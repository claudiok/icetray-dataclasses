/**
 @page stlsyntax STL In The DataClasses

 @author <a href="http://icecube.umd.edu/pretz">John Pretz</a>
 @author <a href="http://www.resophonic.com">Troy Straszheim</a>

 @section summary Summary 
 
 STL is 'Standard Template Library' of C++.  This section summarizes the use 
 of STL in the dataclasses and provides a very short guide to STL syntax, since
 STL syntax is used heavily.  It also provides a brief introduction into 
 how STL syntax is used in the dataclasses.

 @section templates Templates and STL

 Templates are a powerful feature of the C++ language.  If you haven't
 messed with templates before, what are you waiting for?  The
 existence of templates enables the creation of libraries of
 templates, and that is what STL is.  It is a library of common
 templates that is a part of the C++ standard.

 There is not enough <a href="http://en.wikipedia.org/wiki/Time">time</a> to
 give a complete description of STL.  The two class templates that are needed
 to understand the dataclasses are STL's <i>vector</i> and <i>map</i>
 templates.

 @subsection stlvector The Vector Template

 A vector is STL's version of a standard C array.  Just like an array,
 you can fill things in places, indexed by an integer, throughout the
 array.  Just like an array, you can get the things back out again.
 Among other things, what makes a  
 vector special is that you can automatically get it to expand to hold more
 things.  Furthermore, the allocation and deallocation of space is handled by
 the vector.

 It is probably best to just launch into an example.

 @code
 #include <vector>
 #include <iostream> 

 using namespace std;

 int main()
 {
   // declaring a vector of doubles.  It's basically just like a C
   // array of doubles: @c double @c myarray[MAX];
   vector<double> myvector;

   // right now the vector is empty.  Here we give it space for 3 doubles
   myvector.resize(3);

   // and fill the vector with some numbers
   myvector[0]=3.14159;
   myvector[1]=2.71828;
   myvector[2]=1.61803;

   // and get them out again
   for(int i = 0;i<myvector.size();i++)
     cout<<myvector[i]<<" "<<endl;

   // ....easy!
 };
 @endcode

 There is more you can do with a vector, but I just want to show you
 the basics.

 The reason that you will need to know about STL's vector class for the 
 dataclasses is that many of the containers in the dataclasses use the same
 syntax as the vector.

 As another example, take a look at the documentation of the
 I3MCHitSeries class.  
 Notice that I3MCHitSeries inherits from STLVectorStoragePolicy<I3MCHit>.
 This inheritance gives I3MCHitSeries all the public methods of 
 STLVectorStoragePolicy<I3MCHit> which, in turn, gives it all the public 
 methods of vector<I3MCHit>.  So the following is a good code snippit:

 @code
 {
   // declaring the series
   I3MCHitSeries series;

   // making room for two I3MCHits
   series.resize(2);

   // filling them.

   // the data member's already been allocated, so we can just use it
   series[0].SetTime(9.4);
   series[0].SetWeight(1.0);

   // or we can do it this way.
   I3MCHit hit;
   hit.SetTime(2.3);
   hit.SetWeight(1.0);
   series[1]=hit;

   // getting them back out
   for(int i = 0; i < series.size(); i++)
     cout << "An MCHit: " << series[i].GetTime() << " " << series[i].GetWeight() << endl;

   // getting them out a different way
   I3MCHitSeries::iterator iter;
   for(iter = series.begin(); iter != series.end(); iter++)
     cout << "An MCHit: " << iter->GetTime() << " " << iter->GetWeight() << endl;

 }
 @endcode

 The I3MCHitSeries class gets more of the vector interface than just these few
 methods.  Pretty much anything you can do with a vector, you can do with a
 I3MCHitSeries: check the STLVectorStoragePolicy documentation for a
 complete list of the available functions.  Once you know how to use a
 vector, you'll know how to use I3MCHitSeries.

 The same is true in other areas of the dataclasses.  I3TopStationGeo, for 
 instance, is a vector
 of I3TankGeoPtr 's.  So knowing how to use an STL vector shows you how
 the I3TopStationGeo class works, etc.

 Classes in the dataclasses whose names end in 'Vect' are vectors, and
 inherit their interface from STLVectorStoragePolicy.
 
 @subsection stlmap The Map Template

 In addition to the vector, STL comes with a useful 'map' class.  The map class
 takes two template arguments.  The first is the type of 'key' to be used, and
 the second is the type of 'data' to be stored.  The data is put into 
 the container and given a 'key' which is used later to get the data
 out again.  The key is basically a name for the particular element,
 although it can be any type of object, not just a string.
 
 Here's an example of how to use a map:

@code
#include <map>
#include <iostream>
#include <string>
                                                                                
using namespace std;
                                                                                
main(){
  // declaring the map
  map<string,double> mymap;
                                                                                
  // filling the data
  mymap["Pi"] = 3.14159;
  mymap["Euler"]=2.71828;
  mymap["Golden"]=1.61803;
                                                                                
  // printing some of the contents
  cout << "Pi: " << mymap["Pi"];
                                                                                
  // looping over the contents
  map<string,double>::iterator iter;
  for (iter = mymap.begin(); iter != mymap.end(); iter++)
  }
    // 'first' is the key, and 'second' is the contents
    cout << iter->first << " " << iter->second << endl;
  }                                                                             
}
@endcode

In the dataclasses we use maps to represent containers which will hold 
heterogenous results, where the results are best distinguished by a name.

For instance, the I3RecoHitSeriesDict class is a map of I3RecoHitSeriesPtr's.  
Since all of our I3RecoHitSeries results are identified by name (i.e.,
use a string for the key parameter), we neglect 
specifying a generic key type, and the I3RecoHitSeriesDict behaves just like
a map<string,I3RecoHitSeriesPtr>.  (I haven't mentioned the Ptr yet.  For right
now, just read this as map<string,I3RecoHitSeries*> )

So the following code snippet is legitimate:
@code
{
  // declaring the reco hit series data
  I3RecoHitSeriesData rhsdata;
  
  // putting a new reco result in the container
  rhsdata["PretzsResult"]=new I3RecoHitSeries;

  // and getting it out again.  Resizing it for ten I3RecoHit's
  rhsdata["PretzsResult"]->resize(10);
  
  // etc....
}
@endcode

Note that while I3RecoHitSeriesDict is a map, each of the elements 
(which are pointed to by I3RecoHitSeriesPtr 's) is a vector.  So the 
last command in the snippet above is resizing the vector referred to by
the key "PretzsResult".

Classes whose names end in 'Dict' (short for 'Dictionary') 
are maps and inherit the interface 
given in STLMapStoragePolicy.


@section Links

Here are some other tutorials and resources on the net:

<a href=http://www.cs.brown.edu/people/jak/proglang/cpp/stltut/tut.html>
A modest STL tutorial</a>

<a href=http://www.sgi.com/tech/stl/table_of_contents.html>
The SGI documentation for the STL</a>

<a href=http://www.cs.rpi.edu/projects/STL/htdocs/stl.html>
An online STL reference at Rensselaer Polytechnic Institute</a>

<a href=http://www.josuttis.com/libbook/idx.html>
Code examples from the book "The C++ Standard Library - A Tutorial and Reference"</a>

<a href=http://www.halpernwightsoftware.com/stdlib-scratch/quickref.html>
Another STL quick reference, from the book "The C++ Standard Library from Scratch"
</a>

<a href="http://www.cplusplus.com/doc/tutorial/tut5-1.html">A templates tutorial</a> 



*/
